<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N x N Linear Algebra Calculator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for clean input and output */
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .matrix-input {
            width: 40px; /* Reduced size for 3x3/4x4 layout */
            height: 40px;
            text-align: center;
            font-size: 1rem;
            padding: 0.25rem;
        }
        .working-step {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background-color: #f8fafc; /* slate-50 */
            border-radius: 0.375rem;
            font-family: monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        .matrix-display {
            display: inline-flex;
            flex-direction: column;
            border-left: 2px solid black;
            border-right: 2px solid black;
            padding: 0 8px;
            margin: 0 4px;
            font-size: 1rem;
            line-height: 1.25;
        }
        .matrix-row {
            display: flex;
            gap: 8px; /* Reduced gap */
        }
        .matrix-aug {
            border-left: 2px solid black;
            padding-left: 8px;
        }
        #vectorCanvas {
            /* Make canvas responsive within its container */
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8 font-sans">

    <div class="max-w-7xl mx-auto">
        <header class="text-center py-6 mb-8 bg-white shadow-lg rounded-xl">
            <h1 class="text-3xl md:text-5xl font-extrabold text-indigo-700">Linear Algebra Toolkit (N x N)</h1>
            <p class="text-gray-500 mt-2">Gaussian Elimination, Cramer's Rule, and Vector Operations (N-D)</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Gaussian Elimination -->
            <div id="gaussian-elimination" class="bg-white p-6 shadow-xl rounded-xl border border-indigo-100">
                <h2 class="text-2xl font-bold text-indigo-600 mb-4 border-b pb-2">1. Gaussian Elimination</h2>

                <div class="mb-4 flex items-center justify-between">
                    <label for="ge_size_selector" class="text-sm font-medium text-gray-700">Matrix Size (N x N):</label>
                    <select id="ge_size_selector" onchange="renderMatrixInputs('ge', this.value)" class="p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="2">2x2</option>
                        <option value="3">3x3</option>
                        <option value="4">4x4</option>
                    </select>
                </div>

                <p class="text-sm text-gray-500 mb-4" id="ge_equation_info">Enter coefficients for A_1 x + B_1 y = C_1</p>

                <div class="space-y-4" id="ge_input_container">
                    <!-- Inputs rendered here by JS -->
                </div>

                <button onclick="calculateGaussianElimination()" class="w-full bg-indigo-500 text-white py-2 rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md mt-4">Solve</button>

                <h3 class="text-xl font-semibold mt-6 mb-3 text-indigo-700">Result</h3>
                <div id="ge_result" class="p-3 bg-indigo-50 rounded-lg text-gray-800 font-bold">Enter values and click Solve.</div>
                <h3 class="text-xl font-semibold mt-6 mb-3 text-indigo-700">Working</h3>
                <div id="ge_working" class="border border-gray-200 rounded-lg p-3 h-64 overflow-y-auto"></div>
            </div>

            <!-- Cramer's Rule -->
            <div id="cramers-rule" class="bg-white p-6 shadow-xl rounded-xl border border-indigo-100">
                <h2 class="text-2xl font-bold text-indigo-600 mb-4 border-b pb-2">2. Cramer's Rule</h2>

                <div class="mb-4 flex items-center justify-between">
                    <label for="cr_size_selector" class="text-sm font-medium text-gray-700">Matrix Size (N x N):</label>
                    <select id="cr_size_selector" onchange="renderMatrixInputs('cr', this.value)" class="p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="2">2x2</option>
                        <option value="3">3x3</option>
                        <option value="4">4x4</option>
                    </select>
                </div>

                <p class="text-sm text-gray-500 mb-4" id="cr_equation_info">Enter coefficients for A_1 x + B_1 y = C_1</p>

                <div class="space-y-4" id="cr_input_container">
                    <!-- Inputs rendered here by JS -->
                </div>

                <button onclick="calculateCramersRule()" class="w-full bg-indigo-500 text-white py-2 rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md mt-4">Solve</button>

                <h3 class="text-xl font-semibold mt-6 mb-3 text-indigo-700">Result</h3>
                <div id="cr_result" class="p-3 bg-indigo-50 rounded-lg text-gray-800 font-bold">Enter values and click Solve.</div>
                <h3 class="text-xl font-semibold mt-6 mb-3 text-indigo-700">Working</h3>
                <div id="cr_working" class="border border-gray-200 rounded-lg p-3 h-64 overflow-y-auto"></div>
            </div>

            <!-- Vector Operations & Graph -->
            <div id="vector-operations" class="bg-white p-6 shadow-xl rounded-xl border border-indigo-100">
                <h2 class="text-2xl font-bold text-indigo-600 mb-4 border-b pb-2">3. Vector Operations (N-D)</h2>

                <div class="mb-4 flex items-center justify-between">
                    <label for="vo_size_selector" class="text-sm font-medium text-gray-700">Vector Dimension (N):</label>
                    <select id="vo_size_selector" onchange="renderVectorInputs(this.value)" class="p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="2">2D</option>
                        <option value="3">3D</option>
                        <option value="4">4D</option>
                    </select>
                </div>

                <div class="space-y-4" id="vo_input_container">
                    <!-- Inputs rendered here by JS -->
                </div>

                <button onclick="calculateVectorOperations()" class="w-full bg-indigo-500 text-white py-2 rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md mt-4">Calculate & Plot (2D Only)</button>

                <h3 class="text-xl font-semibold mt-6 mb-3 text-indigo-700">Results & Plot</h3>
                <div id="vo_result" class="p-3 bg-indigo-50 rounded-lg text-gray-800 font-bold mb-4">Enter values and click Calculate & Plot.</div>
                <canvas id="vectorCanvas" width="300" height="300" class="border border-gray-300 rounded-lg mx-auto bg-white"></canvas>
                <h3 class="text-xl font-semibold mt-6 mb-3 text-indigo-700">Working</h3>
                <div id="vo_working" class="border border-gray-200 rounded-lg p-3 h-32 overflow-y-auto"></div>
            </div>

        </main>
    </div>

    <script>
        // Utility function to safely get input values as floats
        function getFloatValue(id) {
            const el = document.getElementById(id);
            // If the field is empty, it returns 0, which is handled correctly by the calculations.
            return parseFloat(el.value || 0);
        }

        // Utility to format number to 2 decimal places
        function format(num) {
            // Handle scientific notation for very small numbers
            if (Math.abs(num) < 0.000001 && num !== 0) {
                return num.toExponential(2);
            }
            if (Math.abs(num - Math.round(num)) < 0.000001) {
                return num.toFixed(0); // If effectively integer, show no decimals
            }
            return num.toFixed(2);
        }

        // --- Dynamic Matrix Input Rendering (for GE/CR) ---
        function renderMatrixInputs(idPrefix, size) {
            size = parseInt(size);
            const container = document.getElementById(`${idPrefix}_input_container`);
            const info = document.getElementById(`${idPrefix}_equation_info`);
            let html = '';

            const variables = ['x', 'y', 'z', 'w'];
            const labels = ['A', 'B', 'C', 'D']; // Coefficients
            const constants = ['C', 'D', 'E', 'F']; // Constants on the right

            let equationText = `Enter coefficients for `;
            for(let j = 0; j < size; j++) {
                equationText += `${labels[j]}_1 ${variables[j]}`;
                if (j < size - 1) equationText += ' + ';
            }
            equationText += ` = ${constants[0]}_1`;
            info.innerHTML = equationText;

            for (let i = 1; i <= size; i++) {
                html += `<div class="flex items-center space-x-2">`;
                for (let j = 1; j <= size; j++) {
                    const varChar = variables[j - 1] ? `${variables[j-1]}` : '';
                    const connector = (j < size) ? ' + ' : '';

                    html += `
                        <input type="number" id="${idPrefix}_a${i}${j}" class="matrix-input border rounded-lg focus:ring-indigo-500 focus:border-indigo-500" placeholder="${labels[j-1]}${i}">
                        <span class="text-sm">${varChar}${connector}</span>
                    `;
                }
                // Constant term
                html += `
                    <span class="text-xl">=</span>
                    <input type="number" id="${idPrefix}_b${i}" class="matrix-input border rounded-lg focus:ring-indigo-500 focus:border-indigo-500" placeholder="${constants[0]}${i}">
                `;
                html += `</div>`;
            }
            container.innerHTML = html;
        }

        // Helper to format a N x (N+1) augmented matrix for display
        function formatMatrix(matrix) {
            const displayMatrix = matrix.map(row => {
                const coefficients = row.slice(0, -1).map(val => `<span>${format(val)}</span>`).join('');
                const constant = row[row.length - 1];
                return `<div class="matrix-row">${coefficients}<span class="matrix-aug">${format(constant)}</span></div>`;
            }).join('');

            return `<div class="matrix-display">${displayMatrix}</div>`;
        }

        // --- Determinant Calculation (Recursive Cofactor Expansion) ---
        function getDeterminant(A) {
            const n = A.length;

            if (n === 1) return A[0][0];
            if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0];

            let det = 0;
            // Cofactor expansion along the first row
            for (let j = 0; j < n; j++) {
                // Create the minor matrix (A_ij)
                const minor = [];
                for (let r = 1; r < n; r++) { // Start from the second row
                    const minorRow = [];
                    for (let c = 0; c < n; c++) {
                        if (c !== j) {
                            minorRow.push(A[r][c]);
                        }
                    }
                    minor.push(minorRow);
                }

                // Calculate cofactor sign: (-1)^(i+j). Since i=0 (first row), sign is (-1)^j.
                const sign = (j % 2 === 0) ? 1 : -1;

                det += sign * A[0][j] * getDeterminant(minor);
            }
            return det;
        }


        // --- Gaussian Elimination Core Logic ---
        function calculateGaussianElimination() {
            const size = parseInt(document.getElementById('ge_size_selector').value);
            const resultDiv = document.getElementById('ge_result');
            const workingDiv = document.getElementById('ge_working');
            workingDiv.innerHTML = `<div class="font-bold text-gray-600">Starting System (Size: ${size}x${size}):</div>`;
            const variables = ['x', 'y', 'z', 'w'];

            // 1. Collect inputs into an augmented matrix M
            let M = [];
            for (let i = 1; i <= size; i++) {
                let row = [];
                for (let j = 1; j <= size; j++) {
                    row.push(getFloatValue(`ge_a${i}${j}`));
                }
                row.push(getFloatValue(`ge_b${i}`)); // Constant term
                M.push(row);
            }

            workingDiv.innerHTML += formatMatrix(M) + '<br>';

            // Check singularity using determinant (less prone to floating point errors than the elimination step for this check)
            const det = getDeterminant(M.map(row => row.slice(0, size)));
            if (Math.abs(det) < 0.000001) {
                resultDiv.className = 'p-3 bg-red-100 rounded-lg text-red-800 font-bold';
                resultDiv.innerHTML = 'System has NO UNIQUE solution (Determinant is zero).';
                // FIX: Removed LaTeX $ symbols
                workingDiv.innerHTML += '<div class="working-step text-red-700">Determinant D is zero. No unique solution exists (infinite solutions or no solution).</div>';
                return;
            }

            // 2. Forward Elimination
            for (let i = 0; i < size; i++) { // Pivot row (i)
                const pivot = M[i][i];
                if (Math.abs(pivot) < 0.000001) {
                    // This case *shouldn't* happen if the determinant is non-zero, but in general Gaussian elimination, 
                    // row swapping would occur here. We rely on the determinant check above for simplicity.
                    workingDiv.innerHTML += `<div class="working-step text-red-700">Warning: Attempted row operation with a near-zero pivot. The system might be ill-conditioned.</div>`;
                    continue;
                }

                // Eliminate below pivot
                for (let k = i + 1; k < size; k++) { // Target row (k)
                    const factor = M[k][i] / pivot;
                    // FIX: Replaced $\\times$ with plain *
                    workingDiv.innerHTML += `<div class="working-step">Step: R${k+1} = R${k+1} - (${format(factor)} * R${i+1}) to eliminate ${variables[i]} from R${k+1}.</div>`;

                    for (let j = i; j <= size; j++) { // Column index (j)
                        M[k][j] = M[k][j] - factor * M[i][j];
                        // Correct for floating point inaccuracies
                        if (Math.abs(M[k][j]) < 0.000001) M[k][j] = 0;
                    }
                }
                workingDiv.innerHTML += formatMatrix(M) + '<br>';
            }

            // 3. Back-Substitution
            let solution = new Array(size).fill(0);
            workingDiv.innerHTML += `<div class="font-bold text-gray-600">Back Substitution (Solving from bottom up):</div>`;

            for (let i = size - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < size; j++) {
                    sum += M[i][j] * solution[j];
                }
                solution[i] = (M[i][size] - sum) / M[i][i];
                // FIX: Removed LaTeX $ symbols
                workingDiv.innerHTML += `<div class="working-step">Solve for ${variables[i]}: <br> ${variables[i]} = (${format(M[i][size])} - ${format(sum)}) / ${format(M[i][i])} = ${format(solution[i])}</div>`;
            }

            // Final Result
            const finalResult = solution.map((val, index) => `${variables[index]} = ${format(val)}`).join(', ');
            resultDiv.className = 'p-3 bg-indigo-500 text-white rounded-lg text-xl font-bold';
            resultDiv.innerHTML = `Solution: ${finalResult}`;
        }


        // --- Cramer's Rule Core Logic ---
        function calculateCramersRule() {
            const size = parseInt(document.getElementById('cr_size_selector').value);
            const resultDiv = document.getElementById('cr_result');
            const workingDiv = document.getElementById('cr_working');
            workingDiv.innerHTML = `<div class="font-bold text-gray-600">System of Equations (Size: ${size}x${size}):</div>`;
            const variables = ['x', 'y', 'z', 'w'];

            // 1. Collect inputs
            let A = []; // Coefficient matrix
            let B = []; // Constant vector
            for (let i = 1; i <= size; i++) {
                let row = [];
                for (let j = 1; j <= size; j++) {
                    row.push(getFloatValue(`cr_a${i}${j}`));
                }
                A.push(row);
                B.push(getFloatValue(`cr_b${i}`));
            }

            // Display initial equations
            let equationHtml = '';
            for (let i = 0; i < size; i++) {
                let rowEq = '';
                for (let j = 0; j < size; j++) {
                    rowEq += `${format(A[i][j])}${variables[j]}`;
                    if (j < size - 1) rowEq += ' + ';
                }
                equationHtml += `${rowEq} = ${format(B[i])} <br>`;
            }
            workingDiv.innerHTML += `<div class="working-step">${equationHtml}</div>`;

            // 2. Calculate Determinant D
            const D = getDeterminant(A);

            // FIX: Removed LaTeX $ symbols
            workingDiv.innerHTML += `<div class="working-step">Step 1: Calculate Determinant D (Coefficient Matrix). D = ${format(D)}</div>`;

            if (Math.abs(D) < 0.000001) {
                resultDiv.className = 'p-3 bg-red-100 rounded-lg text-red-800 font-bold';
                resultDiv.innerHTML = 'System has NO UNIQUE solution (Determinant D is zero).';
                // FIX: Removed LaTeX $ symbols
                workingDiv.innerHTML += '<div class="working-step text-red-700">Since D is approximately 0, no unique solution exists (infinite solutions or no solution).</div>';
                return;
            }

            // 3. Calculate Dx, Dy, Dz... and solutions
            let solutions = [];
            let resultDisplay = '';

            for (let i = 0; i < size; i++) {
                // Create temporary matrix A_i by substituting B into column i
                let A_i = A.map(row => [...row]); // Deep copy
                for (let r = 0; r < size; r++) {
                    A_i[r][i] = B[r];
                }

                const D_i = getDeterminant(A_i);
                const val = D_i / D;
                solutions.push(val);

                // FIX: Removed LaTeX $ symbols
                workingDiv.innerHTML += `<div class="working-step">Step ${i + 2}: Calculate Determinant D${variables[i]} (by substituting B into column ${i+1}). <br> D${variables[i]} = ${format(D_i)} <br> ${variables[i]} = D${variables[i]} / D = ${format(D_i)} / ${format(D)} = ${format(val)} </div>`;

                resultDisplay += `${variables[i]} = ${format(val)}`;
                if (i < size - 1) resultDisplay += ', ';
            }

            // Final Result
            resultDiv.className = 'p-3 bg-indigo-500 text-white rounded-lg text-xl font-bold';
            resultDiv.innerHTML = `Solution: ${resultDisplay}`;
        }

        // --- Dynamic Vector Input Rendering (for VO) ---
        function renderVectorInputs(size) {
            size = parseInt(size);
            const container = document.getElementById('vo_input_container');
            const variables = ['x', 'y', 'z', 'w'];
            let html = '';

            // Render V1 inputs
            html += `<div class="flex items-center space-x-1">
                        <span class="text-xl font-semibold">V1: &lt;</span>`;
            for (let i = 0; i < size; i++) {
                html += `<input type="number" id="v1_${variables[i]}" class="matrix-input border rounded-lg focus:ring-indigo-500 focus:border-indigo-500" placeholder="${variables[i]}1">`;
                if (i < size - 1) html += `<span class="text-xl">,</span>`;
            }
            html += `<span class="text-xl">&gt;</span></div>`;

            // Render V2 inputs
            html += `<div class="flex items-center space-x-1">
                        <span class="text-xl font-semibold">V2: &lt;</span>`;
            for (let i = 0; i < size; i++) {
                html += `<input type="number" id="v2_${variables[i]}" class="matrix-input border rounded-lg focus:ring-indigo-500 focus:border-indigo-500" placeholder="${variables[i]}2">`;
                if (i < size - 1) html += `<span class="text-xl">,</span>`;
            }
            html += `<span class="text-xl">&gt;</span></div>`;

            container.innerHTML = html;
        }

        // --- Core Functions for Vector Operations (N-D) ---
        function calculateVectorOperations() {
            const size = parseInt(document.getElementById('vo_size_selector').value);
            const variables = ['x', 'y', 'z', 'w'];
            const resultDiv = document.getElementById('vo_result');
            const workingDiv = document.getElementById('vo_working');
            let V1 = [];
            let V2 = [];

            // 1. Collect inputs
            for (let i = 0; i < size; i++) {
                V1.push(getFloatValue(`v1_${variables[i]}`));
                V2.push(getFloatValue(`v2_${variables[i]}`));
            }

            // 2. Calculations (N-D)
            let V_add = V1.map((v, i) => v + V2[i]);
            let V_sub = V1.map((v, i) => v - V2[i]);
            let dot_product = V1.reduce((sum, v, i) => sum + v * V2[i], 0);
            let mag_v1 = Math.sqrt(V1.reduce((sum, v) => sum + v * v, 0));

            // Helper to format a vector for display
            const formatVector = (V) => {
                return `&lt;${V.map(format).join(', ')}&gt;`;
            };

            // 3. Working Output
            workingDiv.innerHTML = `<div class="font-bold text-gray-600">Input Vectors: V1 = ${formatVector(V1)}, V2 = ${formatVector(V2)}</div>`;

            workingDiv.innerHTML += `<div class="working-step">Addition (V1 + V2): <br> ${formatVector(V1)} + ${formatVector(V2)} = ${formatVector(V_add)}</div>`;
            workingDiv.innerHTML += `<div class="working-step">Subtraction (V1 - V2): <br> ${formatVector(V1)} - ${formatVector(V2)} = ${formatVector(V_sub)}</div>`;
            workingDiv.innerHTML += `<div class="working-step">Dot Product (V1 &middot; V2): <br> Calculation: ${V1.map((v, i) => `(${format(v)} &times; ${format(V2[i])})`).join(' + ')} = ${format(dot_product)}</div>`;
            workingDiv.innerHTML += `<div class="working-step">Magnitude of V1 (||V1||): <br> &radic;(${V1.map(v => `${format(v)}^2`).join(' + ')}) = ${format(mag_v1)}</div>`;

            // 4. Result Output
            resultDiv.className = 'p-3 bg-indigo-500 text-white rounded-lg text-xl font-bold';
            resultDiv.innerHTML = `V1 + V2 = ${formatVector(V_add)} | V1 &middot; V2 = ${format(dot_product)}`;

            // 5. Graphing (Only if 2D)
            const canvas = document.getElementById('vectorCanvas');
            if (size === 2) {
                canvas.style.display = 'block';
                // Pass only the first two elements for 2D plotting
                drawVectors([V1[0], V1[1]], [V2[0], V2[1]], [V_add[0], V_add[1]]);
            } else {
                canvas.style.display = 'none';
                workingDiv.innerHTML += '<div class="working-step text-yellow-700">Plotting is only supported for 2D vectors.</div>';
            }
        }

        // Helper functions for canvas coordinates
        function toCanvasX(x, centerX, scaleFactor) { return centerX + x * scaleFactor; }
        function toCanvasY(y, centerY, scaleFactor) { return centerY - y * scaleFactor; }

        // --- Canvas Drawing Function (fixed and improved label placement) ---
        function drawVectors(V1, V2, V_result) {
            const canvas = document.getElementById('vectorCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;

            // Find the maximum absolute value to determine a safe, dynamic scale
            const maxInputMagnitude = Math.max(
                Math.abs(V1[0]), Math.abs(V1[1]),
                Math.abs(V2[0]), Math.abs(V2[1]),
                Math.abs(V_result[0]), Math.abs(V_result[1]),
                5 // Ensure a minimum view area even with small inputs
            );
            
            // Determine a reasonable scale and label step based on the max value
            let scaleFactor = 1;
            let labelStep = 1;

            // Find the nearest "nice" number for labelStep
            const targetNumLabels = 5; // Aim for about 5 labels on each half-axis
            const roughStep = maxInputMagnitude / targetNumLabels;
            
            if (roughStep <= 1) labelStep = 1;
            else if (roughStep <= 2) labelStep = 2;
            else if (roughStep <= 5) labelStep = 5;
            else {
                // For larger numbers, find the power of 10 and then scale it by 1, 2, or 5
                const exp = Math.floor(Math.log10(roughStep));
                const base = Math.pow(10, exp);
                if (roughStep / base <= 2) labelStep = 2 * base;
                else if (roughStep / base <= 5) labelStep = 5 * base;
                else labelStep = 10 * base;
            }

            // Calculate scaleFactor to ensure all vectors fit and labels are spread well
            scaleFactor = Math.min(
                (centerX - 30) / (Math.ceil(maxInputMagnitude / labelStep) * labelStep || 1), // 30px padding, fallback || 1 to prevent division by zero
                (centerY - 30) / (Math.ceil(maxInputMagnitude / labelStep) * labelStep || 1)
            );
            scaleFactor = Math.max(scaleFactor, 5); // Ensure at least 5 pixels per unit if inputs are tiny

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Draw Grid
            ctx.strokeStyle = '#f0f0f0'; // Lighter grid lines
            ctx.lineWidth = 0.5;

            // X-axis grid lines and labels
            for (let i = -Math.floor(centerX / scaleFactor); i <= Math.floor(centerX / scaleFactor); i += labelStep) {
                if (i === 0) continue; 
                const xCanvas = toCanvasX(i, centerX, scaleFactor);
                
                // Draw vertical grid line
                ctx.beginPath();
                ctx.moveTo(xCanvas, 0);
                ctx.lineTo(xCanvas, height);
                ctx.stroke();

                // Draw X-axis label
                ctx.fillStyle = '#000000';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(i.toString(), xCanvas, centerY + 5);
            }
            
            // Y-axis grid lines and labels
            for (let i = -Math.floor(centerY / scaleFactor); i <= Math.floor(centerY / scaleFactor); i += labelStep) {
                if (i === 0) continue; 
                const yCanvas = toCanvasY(i, centerY, scaleFactor);
                
                // Draw horizontal grid line
                ctx.beginPath();
                ctx.moveTo(0, yCanvas);
                ctx.lineTo(width, yCanvas);
                ctx.stroke();

                // Draw Y-axis label
                ctx.fillStyle = '#000000';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                // Adjust label to be near the axis but not overlap x-axis labels
                ctx.fillText(i.toString(), centerX - 5, yCanvas); 
            }

            // Draw Axes
            ctx.strokeStyle = '#aaaaaa'; // Grayer axes
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height); // Y-axis
            ctx.moveTo(0, centerY); ctx.lineTo(width, centerY); // X-axis
            ctx.stroke();
            
            // Draw Origin Point (The single point requested)
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, Math.PI * 2, true); // Radius 3 point at origin
            ctx.fill();


            // Function to draw an arrow (vector)
            function drawArrow(v, color, label) {
                const startX = centerX;
                const startY = centerY;
                const endX = toCanvasX(v[0], centerX, scaleFactor);
                const endY = toCanvasY(v[1], centerY, scaleFactor);

                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 3;

                // Draw line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Draw Arrowhead (simple triangle)
                const angle = Math.atan2(endY - startY, endX - startX);
                const headLen = 10;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();

                // Draw Label
                ctx.fillStyle = color;
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';
                ctx.fillText(label, endX + 5, endY - 5);
            }

            // Draw vectors 
            drawArrow(V1, '#3b82f6', `V1 <${format(V1[0])}, ${format(V1[1])}>`); // Blue
            drawArrow(V2, '#ef4444', `V2 <${format(V2[0])}, ${format(V2[1])}>`); // Red
            drawArrow(V_result, '#10b981', `V1 + V2 <${format(V_result[0])}, ${format(V_result[1])}>`); // Green

            // Draw the Parallelogram for V_add (optional, but shows visual addition)
            ctx.strokeStyle = '#10b98180';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // Draw V1 translated by V2
            ctx.beginPath();
            ctx.moveTo(toCanvasX(V2[0], centerX, scaleFactor), toCanvasY(V2[1], centerY, scaleFactor));
            ctx.lineTo(toCanvasX(V_result[0], centerX, scaleFactor), toCanvasY(V_result[1], centerY, scaleFactor));
            ctx.stroke();

            // Draw V2 translated by V1
            ctx.beginPath();
            ctx.moveTo(toCanvasX(V1[0], centerX, scaleFactor), toCanvasY(V1[1], centerY, scaleFactor));
            ctx.lineTo(toCanvasX(V_result[0], centerX, scaleFactor), toCanvasY(V_result[1], centerY, scaleFactor));
            ctx.stroke();

            ctx.setLineDash([]); // Reset line dash
        }

        // Initialize the canvas with a grid when the window loads
        window.onload = function() {
            // Initialize 2x2 inputs for all three sections
            renderMatrixInputs('ge', 2);
            renderMatrixInputs('cr', 2);
            renderVectorInputs(2);
            // Draw an empty vector grid on load
            drawVectors([0, 0], [0, 0], [0, 0]);
        };

    </script>
</body>
</html>
